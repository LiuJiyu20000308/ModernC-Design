\newpage
\section{Techniques}

\subsection{Compile-Time Assertions}

The simplest solution to compile-time assertions works in C as well as in
C++, relies on the fact that a zero-length array is illegal.

\begin{verbatim}
#define STATIC_CHECK(expr) { char unnamed[(expr) ? 1 : 0]; }
template <class To, class From>
To safe_reinterpret_cast(From from){
  STATIC_CHECK(sizeof(From) <= sizeof(To));
  return reinterpret_cast<To>(from);
}
void* somePointer = ...;
char c = safe_reinterpret_cast<char>(somePointer);
\end{verbatim}

The problem with this approach is that the error message you receive
is not terribly informative. Error messages have no rules that they
must obey; it's all up to the compiler.

A better solution is to rely on a template with an informative name;
with luck, the compiler will mention the name of that template in the
error message.

\begin{verbatim}
template<bool> struct CompileTimeError;
template<> struct CompileTimeError<true> {};
#define STATIC_CHECK(expr) \
(CompileTimeError<(expr) != 0>())
\end{verbatim}

If you try to instantiate
\texttt{CompileTimeError<false>}, the compiler utters a message such
as "Undefined specialization \texttt{CompileTimeError<false>}." This
message is a slightly better hint that the error is intentional and
not a compiler or a program bug.

Actually, the name \texttt{CompileTimeError} is no longer suggestive
in the new context.

\begin{verbatim}
template<bool> struct CompileTimeChecker{
  CompileTimeChecker(...);
};
template<> struct CompileTimeChecker<false> { };
#define STATIC_CHECK(expr, msg) {\
  class ERROR_##msg {}; \
  (void)sizeof(CompileTimeChecker<(expr) != 0>((ERROR_##msg())));\
}

template <class To, class From>
To safe_reinterpret_cast(From from){
  STATIC_CHECK(sizeof(From) <= sizeof(To),Destination_Type_Too_Narrow);
  return reinterpret_cast<To>(from);
}
void* somePointer = ...;
char c = safe_reinterpret_cast<char>(somePointer);
\end{verbatim}

After macro preprocessing, the code of \texttt{safe\_reinterpret\_cast}
expands to the following:

\begin{verbatim}
template <class To, class From>
To safe_reinterpret_cast(From from){
  class ERROR_Destination_Type_Too_Narrow {};
  (void)sizeof(
    CompileTimeChecker<(sizeof(From) <= sizeof(To))>(
      ERROR_Destination_Type_Too_Narrow()));
  return reinterpret_cast<To>(from);
}
\end{verbatim}

The \texttt{CompileTimeChecker<true>} specialization has a constructor
that accept anything; it's an ellipsis function. If the comparison
between sizes evaluates to false, a decent compiler outputs an error
message such as "Error: Cannot convert
\texttt{ERROR\_Destination\_Type\_Too\_Narrow} to
\texttt{CompileTimeChecker <false>}.

\subsection{Partial Template Specialization}

\begin{verbatim}
template <class Window, class Controller>
class Widget{
  ... generic implementation ...
};

// Partial specialization of Widget
template <class Window>
class Widget<Window, MyController>{
  ... partially specialized implementation ...
};

template <class ButtonArg>
class Widget<Button<ButtonArg>, MyController>{
  ... further specialized implementation ...
};
\end{verbatim}

Unfortunately, partial template specialization does not apply to
functions—be they member or nonmember—which somewhat reduces the
flexibility and the granularity of what you can do:
\begin{itemize}
\item Although you can \textbf{totally specialize} member functions of
  a class template, you cannot \textbf{partially specialize} member
  functions.
\item You cannot partially specialize namespace-level (nonmember)
  template functions. The closest thing to partial specialization for
  namespace-level template functions is overloading (not for changing the
  return value or for internally used type).
\end{itemize}

\begin{verbatim}
template <class T, class U> T Fun(U obj); // primary template
template <class U> void Fun<void, U>(U obj); // illegal partial specialization
template <class T> T Fun (Window obj); // legal (overloading)
\end{verbatim}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../DesignPattern"
%%% End:
