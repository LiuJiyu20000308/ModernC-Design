\newpage
\section{Singleton}

A singleton is an improved global variable. The improvement that
Singleton brings is that you cannot create a secondary object of the
singleton's type.

\subsection{Static Data + Static Functions != Singleton}

There is another pattern, the \textbf{Monostate pattern}:
\begin{verbatim}
class Font { ... };
class PrinterPort { ... };
class PrintJob { ... };

class MyOnlyPrinter{
public:
  static void AddPrintJob(PrintJob& newJob){
    if (printQueue_.empty() && printingPort_.available()){
      printingPort_.send(newJob.Data());
    }else{
      printQueue_.push(newJob);
    }
  }
private:
  // All data is static
  static std::queue<PrintJob> printQueue_;
  static PrinterPort printingPort_;
  static Font defaultFont_;
};
\end{verbatim}

The main problem is that static functions cannot be virtual, which
makes it difficult to change behavior without opening
\texttt{MyOnlyPrinter}'s code.

\subsection{The Basic C++ Idioms Supporting Singletons}

Most often, singletons are implemented in C++ by using some variation
of the following idiom:
\begin{verbatim}
class Singleton{
public:
  static Singleton* Instance(){
    if (!pInstance_)
      pInstance_ = new Singleton;
    return pInstance_;
  }
... operations ...
private:
  Singleton(); // Prevent clients from creating a new Singleton
  Singleton(const Singleton&); // Prevent clients from creating
  static Singleton* pInstance_; // The one and only instance
};
// Implementation file Singleton.cpp
Singleton* Singleton::pInstance_ = 0;
\end{verbatim}

If it's never used (no call to \texttt{Instance} occurs), the
\texttt{Singleton} object is not created. The advantage of the
build-on-first-request solution becomes significant if
\texttt{Singleton} is expensive to create and seldom used. 


An ill-fated temptation is to simplify things by replacing the pointer
\texttt{pInstance\_} in the previous example with a full Singleton
object.
\begin{verbatim}
class Singleton{
public:
  static Singleton* Instance() // Unique point of access{
    return &instance_;
  }
private:
  static Singleton instance_;
};
// Implementation file Singleton.cpp
Singleton Singleton::instance_;
\end{verbatim}

\texttt{instance\_} is initialized dynamically (by calling
\texttt{Singleton}'s constructor at runtime), whereas 
\texttt{pInstance\_} benefits from static initialization (it is a type
without a constructor initialized with a compile-time constant).

\begin{verbatim}
#include "Singleton.h"
int global = Singleton::Instance()->DoSomething();
\end{verbatim}

Depending on the order of initialization that the compiler chooses for
\texttt{instance\_} and \texttt{global}, the call to
\texttt{Singleton::Instance} may return an object that has not been
constructed yet.

\subsection{Enforcing the Singleton's Uniqueness}

 The default constructor and the copy constructor, the assignment
 operator are private.

 The problem with having Instance return a pointer is that callers
 might be tempted to \texttt{delete} it. To minimize the
chances of that happening, it's safer to return a reference:
\begin{verbatim}
// inside class Singleton
static Singleton& Instance();
\end{verbatim}

After the enumerated measures are added, Singleton's interface looks
like the following.
\begin{verbatim}
class Singleton{
public:
  Singleton& Instance();
  ... operations ...
private:
  Singleton();
  Singleton(const Singleton&);
  Singleton& operator=(const Singleton&);
  ~Singleton();
};
\end{verbatim}

\subsection{Destroying the Singleton}

If \texttt{Singleton} is not deleted, that's not a memory
leak. \textbf{Memory leaks appear when you allocate accumulating
dataand lose all references to it.  } 

However, \textbf{there is a leak, and a more insidious one: a resource
leak.}  Singleton's constructor may acquire an unbound set of
resources: network connections, handles to OS-wide mutexes and other
interprocess communication means and so on. The only correct way to
avoid resource leaks is to delete the Singleton object during the
application's shutdown.

The simplest solution for destroying the singleton is to \textbf{rely on
  language mechanisms}:
\begin{verbatim}
Singleton& Singleton::Instance(){
  static Singleton obj;
  return obj;
}
\end{verbatim}

This \texttt{Meyers singleton} relies on some compiler magic. When the
initializer is not a compile-time constant, or the static variable is
an object with a constructor,\textbf{ the variable is initialized at runtime
  during the first pass through its definition.}

In addition, the compiler generates code so that after initialization,
the pseudo-C++ representation of the generated code may look like the
following code:
\begin{verbatim}
Singleton& Singleton::Instance(){
  // Functions generated by the compiler
  extern void __ConstructSingleton(void* memory);
  extern void __DestroySingleton();
  // Variables generated by the compiler
  static bool __initialized = false;
  // Buffer that holds the singleton
  // (We assume it is properly aligned)
  static char __buffer[sizeof(Singleton)];
  if (!__initialized){
    // First call, construct object
    // Will invoke Singleton::Singleton
    // In the __buffer memory
    __ConstructSingleton(__buffer);
    // register destruction
    atexit(__DestroySingleton);
    __initialized = true;
  }
  return *reinterpret_cast<Singleton *>(__buffer);
}
\end{verbatim}

\textbf{The core is the call to the \texttt{atexit} function}, which
allows you to register functions to be automatically called during a
program's exit, in a last in, first out (LIFO) order. Each call to
atexit pushes its parameter on a private stack maintained by the C
runtime library.

\subsection{The Dead Reference Problem}

Assuming we implement \texttt{Keyboard}, \texttt{Display},
\texttt{Log} with three singletons as Meyers singletons. Assume that
after \texttt{Keyboard} is constructed successfully, \texttt{Display}
fails to initialize. \texttt{Display}'s constructor creates
\texttt{Log}, the error is logged.

At exit time,  \texttt{Log} is destroyed before \texttt{Keyboard}. If
for some reason \texttt{Keyboard} fails to shut down and tries to
report an error to \texttt{Log}, \texttt{Log::Instance} unwittingly
returns a reference to the "shell" of  a destroyed \texttt{Log}
object.  So \textbf{a reasonable singleton should at least perform
  dead-reference \emph{detection}.}

\begin{verbatim}
class Singleton{
public:
  Singleton& Instance(){
    if (!pInstance_){
      if (destroyed_){
        OnDeadReference();
      }else{
        Create();
      }
    }
    return *pInstance_;
  }
private:
  static void Create(){
    static Singleton theInstance;
    pInstance_ = &theInstance;
  }
  static void OnDeadReference(){
    throw std::runtime_error("Dead Reference Detected");
  }
  virtual ~Singleton(){
    pInstance_ = 0;
    destroyed_ = true;
  }

  Singleton *pInstance_;
  bool destroyed_;
  ... disabled 'tors/operator= ...
};

// Singleton.cpp
Singleton* Singleton::pInstance_ = 0;
bool Singleton::destroyed_ = false;
\end{verbatim}

\subsection{Addressing the Dead Reference Problem (I):
  The Phoenix Singleton}

The implementation of the Phoenix Singleton with a static variable is
simple. When we detect the dead reference, we create a new
\texttt{Singleton} object in the shell of the old one. (C++ guarantees
this is possible. Static objects' memory lasts for the duration of the
program.)

\begin{verbatim}
class Singleton{
  ... as before ...
  void KillPhoenixSingleton(); // Added
};
void Singleton::OnDeadReference(){
  Create();
  // Now pInstance_ points to the "ashes" of the singleton
  // - the raw memory that the singleton was seated in.
  // Create a new singleton at that address
  new(pInstance_) Singleton;
  // Queue this new object's destruction
  atexit(KillPhoenixSingleton);
  // Reset destroyed_ because we're back in business
  destroyed_ = false;
}
void Singleton::KillPhoenixSingleton(){
  pInstance_->~Singleton();
}
\end{verbatim}

The \texttt{new} operator that \texttt{OnDeadReference} uses is called
the placement \texttt{new} operator. The placement \texttt{new}
operator does not allocate memory; it only constructs a new object at
the address passed—in our case, \texttt{pInstance\_}.

\begin{verbatim}
#ifdef ATEXIT_FIXED
atexit(KillPhoenixSingleton);
#endif
\end{verbatim}

This measure has to do with an unfortunate omission in the C++
standard. The standard fails to describe what happens when you
register functions with atexit during a call made as the effect of
another \texttt{atexit} registration. To illustrate this problem,
let's write a short test program: 
\begin{verbatim}
#include <cstdlib>
void Bar(){ ... }
void Foo(){ std::atexit(Bar); }
int main(){
  std::atexit(Foo);
}
\end{verbatim}

They say that \texttt{Bar} will be called before \texttt{Foo} because
\texttt{Bar} was registered last, but at  the time it's registered,
it's too late for \texttt{Bar} to be first because \texttt{Foo} is
already being called.

\subsection{Addressing the Dead Reference Problem (II):
  Singletons with Longevity}

The Phoenix singleton breaks the normal lifetime cycle of a singleton,
which may confuse some clients.

Setting longevity control applies not only to singletons but also to
global objects in general. The concept emerging here is that of
longevity control and is independent of the concept of a singleton: 
\textbf{The greater longevity an object has, the later it will be
  destroyed. }

\begin{verbatim}
class SomeSingleton { ... };
class SomeClass { ... };
SomeClass* pGlobalObject(new SomeClass);
int main(){
  SetLongevity(&SomeSingleton().Instance(), 5);
  SetLongevity(pGlobalObject, 6);
}
\end{verbatim}
The function \texttt{SetLongevity} takes a reference to an object of
any type and an integral value (the longevity).

\textbf{You cannot apply SetLongevity to objects whose lifetimes are
  controlled by the compiler}, such as regular global objects, static
objects, and automatic objects. The compiler already generates code
for destroying them.

\begin{verbatim}
class SomeClass { ... };
int main(){
  SomeClass* pObj1 = new SomeClass;
  SetLongevity(pObj1, 5);
  static SomeClass obj2;
  SomeClass* pObj3 = new SomeClass;
  SetLongevity(pObj3, 6);
}
\end{verbatim}
A careful constraints analysis leads to the following design
decisions:
\begin{enumerate}
\item Each call to \texttt{SetLongevity} issues a call to
  \texttt{atexit}.
\item Destruction of objects with lesser longevity takes place before
  destruction of objects with greater longevity.
\item Destruction of objects with the same longevity follows the C++
  rule: last built, first destroyed. 
\end{enumerate}

In the example program, the rules lead to the following guaranteed
order of destruction: \texttt{*pObj1, obj2, *pObj3}.

\subsection{Implementing Singletons with Longevity}

\texttt{SetLongevity} maintains a hidden \texttt{priority queue},
separate from the inaccessible \texttt{atexit} stack. The core is the
priority queue data structure. We cannot use the standard
\texttt{std::priority\_queue} class because \textbf{it does not
  guarantee the ordering of the elements having the same priority.}

The elements that the data structure holds are pointers to the type
\texttt{LifetimeTracker}.
\begin{verbatim}
class LifetimeTracker{
public:
  LifetimeTracker(unsigned int x) : longevity_(x) {}
  virtual ~LifetimeTracker() = 0;
  friend inline bool Compare(unsigned int longevity, const LifetimeTracker* p){
  return p->longevity_ > longevity;
  }
private:
  unsigned int longevity_;
};
// Definition required
inline LifetimeTracker::~LifetimeTracker() {}

typedef LifetimeTracker** TrackerArray;
extern TrackerArray pTrackerArray;
extern unsigned int elements;
\end{verbatim}

There is only one instance of the \texttt{Tracker} type. Consequently,
\texttt{pTrackerArray} is exposed to all the Singleton problems just
discussed, \texttt{SetLongevity} must be available at any time. To
deal with this problem, \texttt{SetLongevity} carefully 
manipulates \texttt{pTrackerArray} with the low-level functions
\texttt{realloc}. if you call it with a zero size, it behaves like
\texttt{std::free}.

\begin{verbatim}
//Helper destroyer function
template <typename T>
struct Deleter{
  static void Delete(T* pObj){ delete pObj; }
};
// Concrete lifetime tracker for objects of type T
template <typename T, typename Destroyer>
class ConcreteLifetimeTracker : public LifetimeTracker{
public:
  ConcreteLifetimeTracker(T* p, unsigned int longevity, Destroyer d) : LifetimeTracker(longevity), pTracked_(p), destroyer_(d){}
  ~ConcreteLifetimeTracker(){ destroyer_(pTracked_); }
private:
  T* pTracked_;
  Destroyer destroyer_;
};

void AtExitFn(); // Declaration needed below

template <typename T, typename Destroyer>
void SetLongevity(T* pDynObject, unsigned int longevity,Destroyer d = Private::Deleter<T>::Delete){
  TrackerArray pNewArray = static_cast<TrackerArray>(
  std::realloc(pTrackerArray, sizeof(T) * (elements + 1)));
  if (!pNewArray) throw std::bad_alloc();
  pTrackerArray = pNewArray;
  LifetimeTracker* p = new ConcreteLifetimeTracker<T, Destroyer>(pDynObject, longevity, d);
  TrackerArray pos = std::upper_bound(pTrackerArray, pTrackerArray + elements, longevity, Compare);
  std::copy_backward(pos, pTrackerArray + elements,pTrackerArray + elements + 1);
  *pos = p;
  ++elements;
  std::atexit(AtExitFn);
}
\end{verbatim}

The \texttt{AtExitFn} function pops the object with the smallest
longevity and deletes it. Deleting the pointer to
\texttt{LifetimeTracker} invokes \texttt{ConcreteLifetimeTracker}'s
destructor, which in turn deletes the tracked object.
\begin{verbatim}
static void AtExitFn(){
  assert(elements > 0 && pTrackerArray != 0);
  LifetimeTracker* pTop = pTrackerArray[elements - 1];
  pTrackerArray = static_cast<TrackerArray>(std::realloc(pTrackerArray, sizeof(T) * --elements));
  delete pTop;
}
\end{verbatim}

\subsection{Putting It All Together}

\subsubsection{Decomposing \texttt{SingletonHolde} into Policies}

The three corresponding polices therefore are as follows:
\begin{itemize}
\item \textbf{Creation}. You can create a singleton in various ways.
\item \textbf{Lifetime}. We identified the following lifetime
  policies:
  \begin{enumerate}
  \item Following C++ rules—last created, first destroyed
  \item Recurring (Phoenix singleton)
  \item User controlled (singleton with longevity)
  \item Infinite (the "leaking" singleton, an object that's never destroyed)
  \end{enumerate}
\item \textbf{ThreadingModel}. Whether singleton is single threaded,
  is standard multithreaded or uses a nonportable threading model.
\end{itemize}

\subsubsection{Defining Requirements for \texttt{SingletonHolder}'s
  Policies}

The Creation policy must create and destroy objects, so it must expose
two corresponding functions. \texttt{Creator<T>} must
support the following calls:
\begin{verbatim}
T* pObj = Creator<T>::Create();
Creator<T>::Destroy(pObj);
\end{verbatim}

Lifetime decides the action to be taken if the application violates
the lifetime rules of the Singleton object. Hence:
\begin{itemize}
\item  If you need the singleton to be destroyed according to C++
  rules, then Lifetime uses a mechanism similar to \texttt{atexit}.
\item For the Phoenix singleton, Lifetime still uses an
  \texttt{atexit}-like mechanism but accepts the recreation of the
  Singleton object. 
\item For a singleton with longevity, Lifetime issues a call to
  \texttt{SetLongevity}.
\item For infinite lifetime, Lifetime does not take any action.
\end{itemize}

If \texttt{Lifetime<T>} is a class that implements the Lifetime
policy, the following expressions make sense:
\begin{verbatim}
void (*pDestructionFunction)();
Lifetime<T>::ScheduleDestruction(pDestructionFunction);
Lifetime<T>::OnDeadReference();
\end{verbatim}

\subsubsection{Assembling \texttt{SingletonHolder}}

\begin{verbatim}
template<class T,
  template <class> class CreationPolicy = CreateUsingNew,
  template <class> class LifetimePolicy = DefaultLifetime,
  template <class> class ThreadingModel = SingleThreaded>
class SingletonHolder{
public:
  static T& Instance();
private:
  static void DestroySingleton();
  SingletonHolder();

  typedef ThreadingModel<T>::VolatileType InstanceType;
  static InstanceType* pInstance_;
  static bool destroyed_;
};

template <...>
T& SingletonHolder<...>::Instance(){
  if (!pInstance_){
    typename ThreadingModel<T>::Lock guard;
    if (!pInstance_){
      if (destroyed_){
        LifetimePolicy<T>::OnDeadReference();
        destroyed_ = false;
      }
    pInstance_ = CreationPolicy<T>::Create();
    LifetimePolicy<T>::ScheduleCall(&DestroySingleton);
    }
  }
  return *pInstance_;
}

template <...>
void SingletonHolder<...>::DestroySingleton(){
  assert(!destroyed_);
  CreationPolicy<T>::Destroy(pInstance_);
  pInstance_ = 0;
  destroyed_ = true;
}
\end{verbatim}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../DesignPattern"
%%% End:
